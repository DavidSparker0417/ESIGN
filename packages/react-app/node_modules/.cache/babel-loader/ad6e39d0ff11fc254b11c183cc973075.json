{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n\nfunction now() {\n  return new Date().getTime();\n} // Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\n\n\nfunction checkNetworks(networks) {\n  let result = null;\n\n  for (let i = 0; i < networks.length; i++) {\n    const network = networks[i]; // Null! We do not know our network; bail.\n\n    if (network == null) {\n      return null;\n    }\n\n    if (result) {\n      // Make sure the network matches the previous networks\n      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {\n        logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n      }\n    } else {\n      result = network;\n    }\n  }\n\n  return result;\n}\n\nfunction median(values, maxDelta) {\n  values = values.slice().sort();\n  const middle = Math.floor(values.length / 2); // Odd length; take the middle\n\n  if (values.length % 2) {\n    return values[middle];\n  } // Even length; take the average of the two middle\n\n\n  const a = values[middle - 1],\n        b = values[middle];\n\n  if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n    return null;\n  }\n\n  return (a + b) / 2;\n}\n\nfunction serialize(value) {\n  if (value === null) {\n    return \"null\";\n  } else if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return JSON.stringify(value);\n  } else if (typeof value === \"string\") {\n    return value;\n  } else if (BigNumber.isBigNumber(value)) {\n    return value.toString();\n  } else if (Array.isArray(value)) {\n    return JSON.stringify(value.map(i => serialize(i)));\n  } else if (typeof value === \"object\") {\n    const keys = Object.keys(value);\n    keys.sort();\n    return \"{\" + keys.map(key => {\n      let v = value[key];\n\n      if (typeof v === \"function\") {\n        v = \"[function]\";\n      } else {\n        v = serialize(v);\n      }\n\n      return JSON.stringify(key) + \":\" + v;\n    }).join(\",\") + \"}\";\n  }\n\n  throw new Error(\"unknown value type: \" + typeof value);\n} // Next request ID to use for emitting debug info\n\n\nlet nextRid = 1;\n;\n\nfunction stall(duration) {\n  let cancel = null;\n  let timer = null;\n  let promise = new Promise(resolve => {\n    cancel = function () {\n      if (timer) {\n        clearTimeout(timer);\n        timer = null;\n      }\n\n      resolve();\n    };\n\n    timer = setTimeout(cancel, duration);\n  });\n\n  const wait = func => {\n    promise = promise.then(func);\n    return promise;\n  };\n\n  function getPromise() {\n    return promise;\n  }\n\n  return {\n    cancel,\n    getPromise,\n    wait\n  };\n}\n\nconst ForwardErrors = [Logger.errors.CALL_EXCEPTION, Logger.errors.INSUFFICIENT_FUNDS, Logger.errors.NONCE_EXPIRED, Logger.errors.REPLACEMENT_UNDERPRICED, Logger.errors.UNPREDICTABLE_GAS_LIMIT];\nconst ForwardProperties = [\"address\", \"args\", \"errorArgs\", \"errorSignature\", \"method\", \"transaction\"];\n;\n\nfunction exposeDebugConfig(config, now) {\n  const result = {\n    weight: config.weight\n  };\n  Object.defineProperty(result, \"provider\", {\n    get: () => config.provider\n  });\n\n  if (config.start) {\n    result.start = config.start;\n  }\n\n  if (now) {\n    result.duration = now - config.start;\n  }\n\n  if (config.done) {\n    if (config.error) {\n      result.error = config.error;\n    } else {\n      result.result = config.result || null;\n    }\n  }\n\n  return result;\n}\n\nfunction normalizedTally(normalize, quorum) {\n  return function (configs) {\n    // Count the votes for each result\n    const tally = {};\n    configs.forEach(c => {\n      const value = normalize(c.result);\n\n      if (!tally[value]) {\n        tally[value] = {\n          count: 0,\n          result: c.result\n        };\n      }\n\n      tally[value].count++;\n    }); // Check for a quorum on any given result\n\n    const keys = Object.keys(tally);\n\n    for (let i = 0; i < keys.length; i++) {\n      const check = tally[keys[i]];\n\n      if (check.count >= quorum) {\n        return check.result;\n      }\n    } // No quroum\n\n\n    return undefined;\n  };\n}\n\nfunction getProcessFunc(provider, method, params) {\n  let normalize = serialize;\n\n  switch (method) {\n    case \"getBlockNumber\":\n      // Return the median value, unless there is (median + 1) is also\n      // present, in which case that is probably true and the median\n      // is going to be stale soon. In the event of a malicious node,\n      // the lie will be true soon enough.\n      return function (configs) {\n        const values = configs.map(c => c.result); // Get the median block number\n\n        let blockNumber = median(configs.map(c => c.result), 2);\n\n        if (blockNumber == null) {\n          return undefined;\n        }\n\n        blockNumber = Math.ceil(blockNumber); // If the next block height is present, its prolly safe to use\n\n        if (values.indexOf(blockNumber + 1) >= 0) {\n          blockNumber++;\n        } // Don't ever roll back the blockNumber\n\n\n        if (blockNumber >= provider._highestBlockNumber) {\n          provider._highestBlockNumber = blockNumber;\n        }\n\n        return provider._highestBlockNumber;\n      };\n\n    case \"getGasPrice\":\n      // Return the middle (round index up) value, similar to median\n      // but do not average even entries and choose the higher.\n      // Malicious actors must compromise 50% of the nodes to lie.\n      return function (configs) {\n        const values = configs.map(c => c.result);\n        values.sort();\n        return values[Math.floor(values.length / 2)];\n      };\n\n    case \"getEtherPrice\":\n      // Returns the median price. Malicious actors must compromise at\n      // least 50% of the nodes to lie (in a meaningful way).\n      return function (configs) {\n        return median(configs.map(c => c.result));\n      };\n    // No additional normalizing required; serialize is enough\n\n    case \"getBalance\":\n    case \"getTransactionCount\":\n    case \"getCode\":\n    case \"getStorageAt\":\n    case \"call\":\n    case \"estimateGas\":\n    case \"getLogs\":\n      break;\n    // We drop the confirmations from transactions as it is approximate\n\n    case \"getTransaction\":\n    case \"getTransactionReceipt\":\n      normalize = function (tx) {\n        if (tx == null) {\n          return null;\n        }\n\n        tx = shallowCopy(tx);\n        tx.confirmations = -1;\n        return serialize(tx);\n      };\n\n      break;\n    // We drop the confirmations from transactions as it is approximate\n\n    case \"getBlock\":\n      // We drop the confirmations from transactions as it is approximate\n      if (params.includeTransactions) {\n        normalize = function (block) {\n          if (block == null) {\n            return null;\n          }\n\n          block = shallowCopy(block);\n          block.transactions = block.transactions.map(tx => {\n            tx = shallowCopy(tx);\n            tx.confirmations = -1;\n            return tx;\n          });\n          return serialize(block);\n        };\n      } else {\n        normalize = function (block) {\n          if (block == null) {\n            return null;\n          }\n\n          return serialize(block);\n        };\n      }\n\n      break;\n\n    default:\n      throw new Error(\"unknown method: \" + method);\n  } // Return the result if and only if the expected quorum is\n  // satisfied and agreed upon for the final result.\n\n\n  return normalizedTally(normalize, provider.quorum);\n} // If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\n\n\nfunction waitForSync(config, blockNumber) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const provider = config.provider;\n\n    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {\n      return provider;\n    }\n\n    return poll(() => {\n      return new Promise((resolve, reject) => {\n        setTimeout(function () {\n          // We are synced\n          if (provider.blockNumber >= blockNumber) {\n            return resolve(provider);\n          } // We're done; just quit\n\n\n          if (config.cancelled) {\n            return resolve(null);\n          } // Try again, next block\n\n\n          return resolve(undefined);\n        }, 0);\n      });\n    }, {\n      oncePoll: provider\n    });\n  });\n}\n\nfunction getRunner(config, currentBlockNumber, method, params) {\n  return __awaiter(this, void 0, void 0, function* () {\n    let provider = config.provider;\n\n    switch (method) {\n      case \"getBlockNumber\":\n      case \"getGasPrice\":\n        return provider[method]();\n\n      case \"getEtherPrice\":\n        if (provider.getEtherPrice) {\n          return provider.getEtherPrice();\n        }\n\n        break;\n\n      case \"getBalance\":\n      case \"getTransactionCount\":\n      case \"getCode\":\n        if (params.blockTag && isHexString(params.blockTag)) {\n          provider = yield waitForSync(config, currentBlockNumber);\n        }\n\n        return provider[method](params.address, params.blockTag || \"latest\");\n\n      case \"getStorageAt\":\n        if (params.blockTag && isHexString(params.blockTag)) {\n          provider = yield waitForSync(config, currentBlockNumber);\n        }\n\n        return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n\n      case \"getBlock\":\n        if (params.blockTag && isHexString(params.blockTag)) {\n          provider = yield waitForSync(config, currentBlockNumber);\n        }\n\n        return provider[params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\"](params.blockTag || params.blockHash);\n\n      case \"call\":\n      case \"estimateGas\":\n        if (params.blockTag && isHexString(params.blockTag)) {\n          provider = yield waitForSync(config, currentBlockNumber);\n        }\n\n        return provider[method](params.transaction);\n\n      case \"getTransaction\":\n      case \"getTransactionReceipt\":\n        return provider[method](params.transactionHash);\n\n      case \"getLogs\":\n        {\n          let filter = params.filter;\n\n          if (filter.fromBlock && isHexString(filter.fromBlock) || filter.toBlock && isHexString(filter.toBlock)) {\n            provider = yield waitForSync(config, currentBlockNumber);\n          }\n\n          return provider.getLogs(filter);\n        }\n    }\n\n    return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n      method: method,\n      params: params\n    });\n  });\n}\n\nexport class FallbackProvider extends BaseProvider {\n  constructor(providers, quorum) {\n    logger.checkNew(new.target, FallbackProvider);\n\n    if (providers.length === 0) {\n      logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n    }\n\n    const providerConfigs = providers.map((configOrProvider, index) => {\n      if (Provider.isProvider(configOrProvider)) {\n        const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n        const priority = 1;\n        return Object.freeze({\n          provider: configOrProvider,\n          weight: 1,\n          stallTimeout,\n          priority\n        });\n      }\n\n      const config = shallowCopy(configOrProvider);\n\n      if (config.priority == null) {\n        config.priority = 1;\n      }\n\n      if (config.stallTimeout == null) {\n        config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n      }\n\n      if (config.weight == null) {\n        config.weight = 1;\n      }\n\n      const weight = config.weight;\n\n      if (weight % 1 || weight > 512 || weight < 1) {\n        logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n      }\n\n      return Object.freeze(config);\n    });\n    const total = providerConfigs.reduce((accum, c) => accum + c.weight, 0);\n\n    if (quorum == null) {\n      quorum = total / 2;\n    } else if (quorum > total) {\n      logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n    } // Are all providers' networks are known\n\n\n    let networkOrReady = checkNetworks(providerConfigs.map(c => c.provider.network)); // Not all networks are known; we must stall\n\n    if (networkOrReady == null) {\n      networkOrReady = new Promise((resolve, reject) => {\n        setTimeout(() => {\n          this.detectNetwork().then(resolve, reject);\n        }, 0);\n      });\n    }\n\n    super(networkOrReady); // Preserve a copy, so we do not get mutated\n\n    defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n    defineReadOnly(this, \"quorum\", quorum);\n    this._highestBlockNumber = -1;\n  }\n\n  detectNetwork() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const networks = yield Promise.all(this.providerConfigs.map(c => c.provider.getNetwork()));\n      return checkNetworks(networks);\n    });\n  }\n\n  perform(method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Sending transactions is special; always broadcast it to all backends\n      if (method === \"sendTransaction\") {\n        const results = yield Promise.all(this.providerConfigs.map(c => {\n          return c.provider.sendTransaction(params.signedTransaction).then(result => {\n            return result.hash;\n          }, error => {\n            return error;\n          });\n        })); // Any success is good enough (other errors are likely \"already seen\" errors\n\n        for (let i = 0; i < results.length; i++) {\n          const result = results[i];\n\n          if (typeof result === \"string\") {\n            return result;\n          }\n        } // They were all an error; pick the first error\n\n\n        throw results[0];\n      } // We need to make sure we are in sync with our backends, so we need\n      // to know this before we can make a lot of calls\n\n\n      if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n        yield this.getBlockNumber();\n      }\n\n      const processFunc = getProcessFunc(this, method, params); // Shuffle the providers and then sort them by their priority; we\n      // shallowCopy them since we will store the result in them too\n\n      const configs = shuffled(this.providerConfigs.map(shallowCopy));\n      configs.sort((a, b) => a.priority - b.priority);\n      const currentBlockNumber = this._highestBlockNumber;\n      let i = 0;\n      let first = true;\n\n      while (true) {\n        const t0 = now(); // Compute the inflight weight (exclude anything past)\n\n        let inflightWeight = configs.filter(c => c.runner && t0 - c.start < c.stallTimeout).reduce((accum, c) => accum + c.weight, 0); // Start running enough to meet quorum\n\n        while (inflightWeight < this.quorum && i < configs.length) {\n          const config = configs[i++];\n          const rid = nextRid++;\n          config.start = now();\n          config.staller = stall(config.stallTimeout);\n          config.staller.wait(() => {\n            config.staller = null;\n          });\n          config.runner = getRunner(config, currentBlockNumber, method, params).then(result => {\n            config.done = true;\n            config.result = result;\n\n            if (this.listenerCount(\"debug\")) {\n              this.emit(\"debug\", {\n                action: \"request\",\n                rid: rid,\n                backend: exposeDebugConfig(config, now()),\n                request: {\n                  method: method,\n                  params: deepCopy(params)\n                },\n                provider: this\n              });\n            }\n          }, error => {\n            config.done = true;\n            config.error = error;\n\n            if (this.listenerCount(\"debug\")) {\n              this.emit(\"debug\", {\n                action: \"request\",\n                rid: rid,\n                backend: exposeDebugConfig(config, now()),\n                request: {\n                  method: method,\n                  params: deepCopy(params)\n                },\n                provider: this\n              });\n            }\n          });\n\n          if (this.listenerCount(\"debug\")) {\n            this.emit(\"debug\", {\n              action: \"request\",\n              rid: rid,\n              backend: exposeDebugConfig(config, null),\n              request: {\n                method: method,\n                params: deepCopy(params)\n              },\n              provider: this\n            });\n          }\n\n          inflightWeight += config.weight;\n        } // Wait for anything meaningful to finish or stall out\n\n\n        const waiting = [];\n        configs.forEach(c => {\n          if (c.done || !c.runner) {\n            return;\n          }\n\n          waiting.push(c.runner);\n\n          if (c.staller) {\n            waiting.push(c.staller.getPromise());\n          }\n        });\n\n        if (waiting.length) {\n          yield Promise.race(waiting);\n        } // Check the quorum and process the results; the process function\n        // may additionally decide the quorum is not met\n\n\n        const results = configs.filter(c => c.done && c.error == null);\n\n        if (results.length >= this.quorum) {\n          const result = processFunc(results);\n\n          if (result !== undefined) {\n            // Shut down any stallers\n            configs.forEach(c => {\n              if (c.staller) {\n                c.staller.cancel();\n              }\n\n              c.cancelled = true;\n            });\n            return result;\n          }\n\n          if (!first) {\n            yield stall(100).getPromise();\n          }\n\n          first = false;\n        } // No result, check for errors that should be forwarded\n\n\n        const errors = configs.reduce((accum, c) => {\n          if (!c.done || c.error == null) {\n            return accum;\n          }\n\n          const code = c.error.code;\n\n          if (ForwardErrors.indexOf(code) >= 0) {\n            if (!accum[code]) {\n              accum[code] = {\n                error: c.error,\n                weight: 0\n              };\n            }\n\n            accum[code].weight += c.weight;\n          }\n\n          return accum;\n        }, {});\n        Object.keys(errors).forEach(errorCode => {\n          const tally = errors[errorCode];\n\n          if (tally.weight < this.quorum) {\n            return;\n          } // Shut down any stallers\n\n\n          configs.forEach(c => {\n            if (c.staller) {\n              c.staller.cancel();\n            }\n\n            c.cancelled = true;\n          });\n          const e = tally.error;\n          const props = {};\n          ForwardProperties.forEach(name => {\n            if (e[name] == null) {\n              return;\n            }\n\n            props[name] = e[name];\n          });\n          logger.throwError(e.reason || e.message, errorCode, props);\n        }); // All configs have run to completion; we will never get more data\n\n        if (configs.filter(c => !c.done).length === 0) {\n          break;\n        }\n      } // Shut down any stallers; shouldn't be any\n\n\n      configs.forEach(c => {\n        if (c.staller) {\n          c.staller.cancel();\n        }\n\n        c.cancelled = true;\n      });\n      return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n        method: method,\n        params: params,\n        //results: configs.map((c) => c.result),\n        //errors: configs.map((c) => c.error),\n        results: configs.map(c => exposeDebugConfig(c)),\n        provider: this\n      });\n    });\n  }\n\n}","map":{"version":3,"sources":["../src.ts/fallback-provider.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { shuffled } from \"@ethersproject/random\";\nimport { poll } from \"@ethersproject/web\";\nimport { BaseProvider } from \"./base-provider\";\nimport { isCommunityResource } from \"./formatter\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nfunction now() { return (new Date()).getTime(); }\n// Returns to network as long as all agree, or null if any is null.\n// Throws an error if any two networks do not match.\nfunction checkNetworks(networks) {\n    let result = null;\n    for (let i = 0; i < networks.length; i++) {\n        const network = networks[i];\n        // Null! We do not know our network; bail.\n        if (network == null) {\n            return null;\n        }\n        if (result) {\n            // Make sure the network matches the previous networks\n            if (!(result.name === network.name && result.chainId === network.chainId &&\n                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {\n                logger.throwArgumentError(\"provider mismatch\", \"networks\", networks);\n            }\n        }\n        else {\n            result = network;\n        }\n    }\n    return result;\n}\nfunction median(values, maxDelta) {\n    values = values.slice().sort();\n    const middle = Math.floor(values.length / 2);\n    // Odd length; take the middle\n    if (values.length % 2) {\n        return values[middle];\n    }\n    // Even length; take the average of the two middle\n    const a = values[middle - 1], b = values[middle];\n    if (maxDelta != null && Math.abs(a - b) > maxDelta) {\n        return null;\n    }\n    return (a + b) / 2;\n}\nfunction serialize(value) {\n    if (value === null) {\n        return \"null\";\n    }\n    else if (typeof (value) === \"number\" || typeof (value) === \"boolean\") {\n        return JSON.stringify(value);\n    }\n    else if (typeof (value) === \"string\") {\n        return value;\n    }\n    else if (BigNumber.isBigNumber(value)) {\n        return value.toString();\n    }\n    else if (Array.isArray(value)) {\n        return JSON.stringify(value.map((i) => serialize(i)));\n    }\n    else if (typeof (value) === \"object\") {\n        const keys = Object.keys(value);\n        keys.sort();\n        return \"{\" + keys.map((key) => {\n            let v = value[key];\n            if (typeof (v) === \"function\") {\n                v = \"[function]\";\n            }\n            else {\n                v = serialize(v);\n            }\n            return JSON.stringify(key) + \":\" + v;\n        }).join(\",\") + \"}\";\n    }\n    throw new Error(\"unknown value type: \" + typeof (value));\n}\n// Next request ID to use for emitting debug info\nlet nextRid = 1;\n;\nfunction stall(duration) {\n    let cancel = null;\n    let timer = null;\n    let promise = (new Promise((resolve) => {\n        cancel = function () {\n            if (timer) {\n                clearTimeout(timer);\n                timer = null;\n            }\n            resolve();\n        };\n        timer = setTimeout(cancel, duration);\n    }));\n    const wait = (func) => {\n        promise = promise.then(func);\n        return promise;\n    };\n    function getPromise() {\n        return promise;\n    }\n    return { cancel, getPromise, wait };\n}\nconst ForwardErrors = [\n    Logger.errors.CALL_EXCEPTION,\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n    Logger.errors.UNPREDICTABLE_GAS_LIMIT\n];\nconst ForwardProperties = [\n    \"address\",\n    \"args\",\n    \"errorArgs\",\n    \"errorSignature\",\n    \"method\",\n    \"transaction\",\n];\n;\nfunction exposeDebugConfig(config, now) {\n    const result = {\n        weight: config.weight\n    };\n    Object.defineProperty(result, \"provider\", { get: () => config.provider });\n    if (config.start) {\n        result.start = config.start;\n    }\n    if (now) {\n        result.duration = (now - config.start);\n    }\n    if (config.done) {\n        if (config.error) {\n            result.error = config.error;\n        }\n        else {\n            result.result = config.result || null;\n        }\n    }\n    return result;\n}\nfunction normalizedTally(normalize, quorum) {\n    return function (configs) {\n        // Count the votes for each result\n        const tally = {};\n        configs.forEach((c) => {\n            const value = normalize(c.result);\n            if (!tally[value]) {\n                tally[value] = { count: 0, result: c.result };\n            }\n            tally[value].count++;\n        });\n        // Check for a quorum on any given result\n        const keys = Object.keys(tally);\n        for (let i = 0; i < keys.length; i++) {\n            const check = tally[keys[i]];\n            if (check.count >= quorum) {\n                return check.result;\n            }\n        }\n        // No quroum\n        return undefined;\n    };\n}\nfunction getProcessFunc(provider, method, params) {\n    let normalize = serialize;\n    switch (method) {\n        case \"getBlockNumber\":\n            // Return the median value, unless there is (median + 1) is also\n            // present, in which case that is probably true and the median\n            // is going to be stale soon. In the event of a malicious node,\n            // the lie will be true soon enough.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                // Get the median block number\n                let blockNumber = median(configs.map((c) => c.result), 2);\n                if (blockNumber == null) {\n                    return undefined;\n                }\n                blockNumber = Math.ceil(blockNumber);\n                // If the next block height is present, its prolly safe to use\n                if (values.indexOf(blockNumber + 1) >= 0) {\n                    blockNumber++;\n                }\n                // Don't ever roll back the blockNumber\n                if (blockNumber >= provider._highestBlockNumber) {\n                    provider._highestBlockNumber = blockNumber;\n                }\n                return provider._highestBlockNumber;\n            };\n        case \"getGasPrice\":\n            // Return the middle (round index up) value, similar to median\n            // but do not average even entries and choose the higher.\n            // Malicious actors must compromise 50% of the nodes to lie.\n            return function (configs) {\n                const values = configs.map((c) => c.result);\n                values.sort();\n                return values[Math.floor(values.length / 2)];\n            };\n        case \"getEtherPrice\":\n            // Returns the median price. Malicious actors must compromise at\n            // least 50% of the nodes to lie (in a meaningful way).\n            return function (configs) {\n                return median(configs.map((c) => c.result));\n            };\n        // No additional normalizing required; serialize is enough\n        case \"getBalance\":\n        case \"getTransactionCount\":\n        case \"getCode\":\n        case \"getStorageAt\":\n        case \"call\":\n        case \"estimateGas\":\n        case \"getLogs\":\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getTransaction\":\n        case \"getTransactionReceipt\":\n            normalize = function (tx) {\n                if (tx == null) {\n                    return null;\n                }\n                tx = shallowCopy(tx);\n                tx.confirmations = -1;\n                return serialize(tx);\n            };\n            break;\n        // We drop the confirmations from transactions as it is approximate\n        case \"getBlock\":\n            // We drop the confirmations from transactions as it is approximate\n            if (params.includeTransactions) {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    block = shallowCopy(block);\n                    block.transactions = block.transactions.map((tx) => {\n                        tx = shallowCopy(tx);\n                        tx.confirmations = -1;\n                        return tx;\n                    });\n                    return serialize(block);\n                };\n            }\n            else {\n                normalize = function (block) {\n                    if (block == null) {\n                        return null;\n                    }\n                    return serialize(block);\n                };\n            }\n            break;\n        default:\n            throw new Error(\"unknown method: \" + method);\n    }\n    // Return the result if and only if the expected quorum is\n    // satisfied and agreed upon for the final result.\n    return normalizedTally(normalize, provider.quorum);\n}\n// If we are doing a blockTag query, we need to make sure the backend is\n// caught up to the FallbackProvider, before sending a request to it.\nfunction waitForSync(config, blockNumber) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const provider = (config.provider);\n        if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {\n            return provider;\n        }\n        return poll(() => {\n            return new Promise((resolve, reject) => {\n                setTimeout(function () {\n                    // We are synced\n                    if (provider.blockNumber >= blockNumber) {\n                        return resolve(provider);\n                    }\n                    // We're done; just quit\n                    if (config.cancelled) {\n                        return resolve(null);\n                    }\n                    // Try again, next block\n                    return resolve(undefined);\n                }, 0);\n            });\n        }, { oncePoll: provider });\n    });\n}\nfunction getRunner(config, currentBlockNumber, method, params) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let provider = config.provider;\n        switch (method) {\n            case \"getBlockNumber\":\n            case \"getGasPrice\":\n                return provider[method]();\n            case \"getEtherPrice\":\n                if (provider.getEtherPrice) {\n                    return provider.getEtherPrice();\n                }\n                break;\n            case \"getBalance\":\n            case \"getTransactionCount\":\n            case \"getCode\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.address, params.blockTag || \"latest\");\n            case \"getStorageAt\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getStorageAt(params.address, params.position, params.blockTag || \"latest\");\n            case \"getBlock\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[(params.includeTransactions ? \"getBlockWithTransactions\" : \"getBlock\")](params.blockTag || params.blockHash);\n            case \"call\":\n            case \"estimateGas\":\n                if (params.blockTag && isHexString(params.blockTag)) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider[method](params.transaction);\n            case \"getTransaction\":\n            case \"getTransactionReceipt\":\n                return provider[method](params.transactionHash);\n            case \"getLogs\": {\n                let filter = params.filter;\n                if ((filter.fromBlock && isHexString(filter.fromBlock)) || (filter.toBlock && isHexString(filter.toBlock))) {\n                    provider = yield waitForSync(config, currentBlockNumber);\n                }\n                return provider.getLogs(filter);\n            }\n        }\n        return logger.throwError(\"unknown method error\", Logger.errors.UNKNOWN_ERROR, {\n            method: method,\n            params: params\n        });\n    });\n}\nexport class FallbackProvider extends BaseProvider {\n    constructor(providers, quorum) {\n        logger.checkNew(new.target, FallbackProvider);\n        if (providers.length === 0) {\n            logger.throwArgumentError(\"missing providers\", \"providers\", providers);\n        }\n        const providerConfigs = providers.map((configOrProvider, index) => {\n            if (Provider.isProvider(configOrProvider)) {\n                const stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n                const priority = 1;\n                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });\n            }\n            const config = shallowCopy(configOrProvider);\n            if (config.priority == null) {\n                config.priority = 1;\n            }\n            if (config.stallTimeout == null) {\n                config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;\n            }\n            if (config.weight == null) {\n                config.weight = 1;\n            }\n            const weight = config.weight;\n            if (weight % 1 || weight > 512 || weight < 1) {\n                logger.throwArgumentError(\"invalid weight; must be integer in [1, 512]\", `providers[${index}].weight`, weight);\n            }\n            return Object.freeze(config);\n        });\n        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);\n        if (quorum == null) {\n            quorum = total / 2;\n        }\n        else if (quorum > total) {\n            logger.throwArgumentError(\"quorum will always fail; larger than total weight\", \"quorum\", quorum);\n        }\n        // Are all providers' networks are known\n        let networkOrReady = checkNetworks(providerConfigs.map((c) => (c.provider).network));\n        // Not all networks are known; we must stall\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then(resolve, reject);\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Preserve a copy, so we do not get mutated\n        defineReadOnly(this, \"providerConfigs\", Object.freeze(providerConfigs));\n        defineReadOnly(this, \"quorum\", quorum);\n        this._highestBlockNumber = -1;\n    }\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const networks = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));\n            return checkNetworks(networks);\n        });\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Sending transactions is special; always broadcast it to all backends\n            if (method === \"sendTransaction\") {\n                const results = yield Promise.all(this.providerConfigs.map((c) => {\n                    return c.provider.sendTransaction(params.signedTransaction).then((result) => {\n                        return result.hash;\n                    }, (error) => {\n                        return error;\n                    });\n                }));\n                // Any success is good enough (other errors are likely \"already seen\" errors\n                for (let i = 0; i < results.length; i++) {\n                    const result = results[i];\n                    if (typeof (result) === \"string\") {\n                        return result;\n                    }\n                }\n                // They were all an error; pick the first error\n                throw results[0];\n            }\n            // We need to make sure we are in sync with our backends, so we need\n            // to know this before we can make a lot of calls\n            if (this._highestBlockNumber === -1 && method !== \"getBlockNumber\") {\n                yield this.getBlockNumber();\n            }\n            const processFunc = getProcessFunc(this, method, params);\n            // Shuffle the providers and then sort them by their priority; we\n            // shallowCopy them since we will store the result in them too\n            const configs = shuffled(this.providerConfigs.map(shallowCopy));\n            configs.sort((a, b) => (a.priority - b.priority));\n            const currentBlockNumber = this._highestBlockNumber;\n            let i = 0;\n            let first = true;\n            while (true) {\n                const t0 = now();\n                // Compute the inflight weight (exclude anything past)\n                let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))\n                    .reduce((accum, c) => (accum + c.weight), 0);\n                // Start running enough to meet quorum\n                while (inflightWeight < this.quorum && i < configs.length) {\n                    const config = configs[i++];\n                    const rid = nextRid++;\n                    config.start = now();\n                    config.staller = stall(config.stallTimeout);\n                    config.staller.wait(() => { config.staller = null; });\n                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {\n                        config.done = true;\n                        config.result = result;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    }, (error) => {\n                        config.done = true;\n                        config.error = error;\n                        if (this.listenerCount(\"debug\")) {\n                            this.emit(\"debug\", {\n                                action: \"request\",\n                                rid: rid,\n                                backend: exposeDebugConfig(config, now()),\n                                request: { method: method, params: deepCopy(params) },\n                                provider: this\n                            });\n                        }\n                    });\n                    if (this.listenerCount(\"debug\")) {\n                        this.emit(\"debug\", {\n                            action: \"request\",\n                            rid: rid,\n                            backend: exposeDebugConfig(config, null),\n                            request: { method: method, params: deepCopy(params) },\n                            provider: this\n                        });\n                    }\n                    inflightWeight += config.weight;\n                }\n                // Wait for anything meaningful to finish or stall out\n                const waiting = [];\n                configs.forEach((c) => {\n                    if (c.done || !c.runner) {\n                        return;\n                    }\n                    waiting.push(c.runner);\n                    if (c.staller) {\n                        waiting.push(c.staller.getPromise());\n                    }\n                });\n                if (waiting.length) {\n                    yield Promise.race(waiting);\n                }\n                // Check the quorum and process the results; the process function\n                // may additionally decide the quorum is not met\n                const results = configs.filter((c) => (c.done && c.error == null));\n                if (results.length >= this.quorum) {\n                    const result = processFunc(results);\n                    if (result !== undefined) {\n                        // Shut down any stallers\n                        configs.forEach(c => {\n                            if (c.staller) {\n                                c.staller.cancel();\n                            }\n                            c.cancelled = true;\n                        });\n                        return result;\n                    }\n                    if (!first) {\n                        yield stall(100).getPromise();\n                    }\n                    first = false;\n                }\n                // No result, check for errors that should be forwarded\n                const errors = configs.reduce((accum, c) => {\n                    if (!c.done || c.error == null) {\n                        return accum;\n                    }\n                    const code = (c.error).code;\n                    if (ForwardErrors.indexOf(code) >= 0) {\n                        if (!accum[code]) {\n                            accum[code] = { error: c.error, weight: 0 };\n                        }\n                        accum[code].weight += c.weight;\n                    }\n                    return accum;\n                }, ({}));\n                Object.keys(errors).forEach((errorCode) => {\n                    const tally = errors[errorCode];\n                    if (tally.weight < this.quorum) {\n                        return;\n                    }\n                    // Shut down any stallers\n                    configs.forEach(c => {\n                        if (c.staller) {\n                            c.staller.cancel();\n                        }\n                        c.cancelled = true;\n                    });\n                    const e = (tally.error);\n                    const props = {};\n                    ForwardProperties.forEach((name) => {\n                        if (e[name] == null) {\n                            return;\n                        }\n                        props[name] = e[name];\n                    });\n                    logger.throwError(e.reason || e.message, errorCode, props);\n                });\n                // All configs have run to completion; we will never get more data\n                if (configs.filter((c) => !c.done).length === 0) {\n                    break;\n                }\n            }\n            // Shut down any stallers; shouldn't be any\n            configs.forEach(c => {\n                if (c.staller) {\n                    c.staller.cancel();\n                }\n                c.cancelled = true;\n            });\n            return logger.throwError(\"failed to meet quorum\", Logger.errors.SERVER_ERROR, {\n                method: method,\n                params: params,\n                //results: configs.map((c) => c.result),\n                //errors: configs.map((c) => c.error),\n                results: configs.map((c) => exposeDebugConfig(c)),\n                provider: this\n            });\n        });\n    }\n}\n//# sourceMappingURL=fallback-provider.js.map"]},"metadata":{},"sourceType":"module"}