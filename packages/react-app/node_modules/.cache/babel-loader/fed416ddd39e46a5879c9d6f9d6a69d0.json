{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\n\nfunction normalize(string) {\n  return string.replace(/[\\s,]+/g, ' ').trim();\n}\n\nfunction cacheKeyFromLoc(loc) {\n  return normalize(loc.source.body.substring(loc.start, loc.end));\n}\n\nfunction processFragments(ast) {\n  var seenKeys = new Set();\n  var definitions = [];\n  ast.definitions.forEach(function (fragmentDefinition) {\n    if (fragmentDefinition.kind === 'FragmentDefinition') {\n      var fragmentName = fragmentDefinition.name.value;\n      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n      var sourceKeySet = fragmentSourceMap.get(fragmentName);\n\n      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n        if (printFragmentWarnings) {\n          console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\" + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\" + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n        }\n      } else if (!sourceKeySet) {\n        fragmentSourceMap.set(fragmentName, sourceKeySet = new Set());\n      }\n\n      sourceKeySet.add(sourceKey);\n\n      if (!seenKeys.has(sourceKey)) {\n        seenKeys.add(sourceKey);\n        definitions.push(fragmentDefinition);\n      }\n    } else {\n      definitions.push(fragmentDefinition);\n    }\n  });\n  return __assign(__assign({}, ast), {\n    definitions: definitions\n  });\n}\n\nfunction stripLoc(doc) {\n  var workSet = new Set(doc.definitions);\n  workSet.forEach(function (node) {\n    if (node.loc) delete node.loc;\n    Object.keys(node).forEach(function (key) {\n      var value = node[key];\n\n      if (value && typeof value === 'object') {\n        workSet.add(value);\n      }\n    });\n  });\n  var loc = doc.loc;\n\n  if (loc) {\n    delete loc.startToken;\n    delete loc.endToken;\n  }\n\n  return doc;\n}\n\nfunction parseDocument(source) {\n  var cacheKey = normalize(source);\n\n  if (!docCache.has(cacheKey)) {\n    var parsed = parse(source, {\n      experimentalFragmentVariables: experimentalFragmentVariables,\n      allowLegacyFragmentVariables: experimentalFragmentVariables\n    });\n\n    if (!parsed || parsed.kind !== 'Document') {\n      throw new Error('Not a valid GraphQL document.');\n    }\n\n    docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n  }\n\n  return docCache.get(cacheKey);\n}\n\nexport function gql(literals) {\n  var args = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    args[_i - 1] = arguments[_i];\n  }\n\n  if (typeof literals === 'string') {\n    literals = [literals];\n  }\n\n  var result = literals[0];\n  args.forEach(function (arg, i) {\n    if (arg && arg.kind === 'Document') {\n      result += arg.loc.source.body;\n    } else {\n      result += arg;\n    }\n\n    result += literals[i + 1];\n  });\n  return parseDocument(result);\n}\nexport function resetCaches() {\n  docCache.clear();\n  fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n  printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n  experimentalFragmentVariables = false;\n}\nvar extras = {\n  gql: gql,\n  resetCaches: resetCaches,\n  disableFragmentWarnings: disableFragmentWarnings,\n  enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n  disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n\n(function (gql_1) {\n  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\n\ngql[\"default\"] = gql;\nexport default gql;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __assign } from \"tslib\";\nimport { parse } from 'graphql';\nvar docCache = new Map();\nvar fragmentSourceMap = new Map();\nvar printFragmentWarnings = true;\nvar experimentalFragmentVariables = false;\nfunction normalize(string) {\n    return string.replace(/[\\s,]+/g, ' ').trim();\n}\nfunction cacheKeyFromLoc(loc) {\n    return normalize(loc.source.body.substring(loc.start, loc.end));\n}\nfunction processFragments(ast) {\n    var seenKeys = new Set();\n    var definitions = [];\n    ast.definitions.forEach(function (fragmentDefinition) {\n        if (fragmentDefinition.kind === 'FragmentDefinition') {\n            var fragmentName = fragmentDefinition.name.value;\n            var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);\n            var sourceKeySet = fragmentSourceMap.get(fragmentName);\n            if (sourceKeySet && !sourceKeySet.has(sourceKey)) {\n                if (printFragmentWarnings) {\n                    console.warn(\"Warning: fragment with name \" + fragmentName + \" already exists.\\n\"\n                        + \"graphql-tag enforces all fragment names across your application to be unique; read more about\\n\"\n                        + \"this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names\");\n                }\n            }\n            else if (!sourceKeySet) {\n                fragmentSourceMap.set(fragmentName, sourceKeySet = new Set);\n            }\n            sourceKeySet.add(sourceKey);\n            if (!seenKeys.has(sourceKey)) {\n                seenKeys.add(sourceKey);\n                definitions.push(fragmentDefinition);\n            }\n        }\n        else {\n            definitions.push(fragmentDefinition);\n        }\n    });\n    return __assign(__assign({}, ast), { definitions: definitions });\n}\nfunction stripLoc(doc) {\n    var workSet = new Set(doc.definitions);\n    workSet.forEach(function (node) {\n        if (node.loc)\n            delete node.loc;\n        Object.keys(node).forEach(function (key) {\n            var value = node[key];\n            if (value && typeof value === 'object') {\n                workSet.add(value);\n            }\n        });\n    });\n    var loc = doc.loc;\n    if (loc) {\n        delete loc.startToken;\n        delete loc.endToken;\n    }\n    return doc;\n}\nfunction parseDocument(source) {\n    var cacheKey = normalize(source);\n    if (!docCache.has(cacheKey)) {\n        var parsed = parse(source, {\n            experimentalFragmentVariables: experimentalFragmentVariables,\n            allowLegacyFragmentVariables: experimentalFragmentVariables\n        });\n        if (!parsed || parsed.kind !== 'Document') {\n            throw new Error('Not a valid GraphQL document.');\n        }\n        docCache.set(cacheKey, stripLoc(processFragments(parsed)));\n    }\n    return docCache.get(cacheKey);\n}\nexport function gql(literals) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    if (typeof literals === 'string') {\n        literals = [literals];\n    }\n    var result = literals[0];\n    args.forEach(function (arg, i) {\n        if (arg && arg.kind === 'Document') {\n            result += arg.loc.source.body;\n        }\n        else {\n            result += arg;\n        }\n        result += literals[i + 1];\n    });\n    return parseDocument(result);\n}\nexport function resetCaches() {\n    docCache.clear();\n    fragmentSourceMap.clear();\n}\nexport function disableFragmentWarnings() {\n    printFragmentWarnings = false;\n}\nexport function enableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = true;\n}\nexport function disableExperimentalFragmentVariables() {\n    experimentalFragmentVariables = false;\n}\nvar extras = {\n    gql: gql,\n    resetCaches: resetCaches,\n    disableFragmentWarnings: disableFragmentWarnings,\n    enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,\n    disableExperimentalFragmentVariables: disableExperimentalFragmentVariables\n};\n(function (gql_1) {\n    gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;\n})(gql || (gql = {}));\ngql[\"default\"] = gql;\nexport default gql;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}