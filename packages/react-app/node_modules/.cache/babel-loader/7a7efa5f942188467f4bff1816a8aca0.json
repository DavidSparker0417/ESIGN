{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useReducer, useState } from 'react';\nimport { NetworkContext } from './context';\nimport { defaultNetworkState, networksReducer } from './reducer';\nimport { Web3Provider, Provider } from '@ethersproject/providers';\nimport { subscribeToProviderEvents, getInjectedProvider } from '../../../helpers';\nimport { useConfig } from '../../config';\nimport { useLocalStorage } from '../../../hooks';\nimport detectEthereumProvider from '@metamask/detect-provider';\n\nasync function tryToGetAccount(provider) {\n  try {\n    return await provider.getSigner().getAddress();\n  } catch (err) {\n    if (err.code === 'UNSUPPORTED_OPERATION') {\n      // readonly provider\n      return undefined;\n    }\n\n    throw err;\n  }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\n\nexport function NetworkProvider(_ref) {\n  let {\n    children,\n    providerOverride\n  } = _ref;\n  const {\n    autoConnect,\n    pollingInterval\n  } = useConfig();\n  const [network, dispatch] = useReducer(networksReducer, defaultNetworkState);\n  const [onUnsubscribe, setOnUnsubscribe] = useState(() => () => undefined);\n  const [shouldConnectMetamask, setShouldConnectMetamask] = useLocalStorage('shouldConnectMetamask');\n  const [isLoading, setLoading] = useState(false);\n  const activateBrowserWallet = useCallback(async () => {\n    setLoading(true);\n    const injectedProvider = await getInjectedProvider(pollingInterval);\n\n    if (!injectedProvider) {\n      reportError(new Error('No injected provider available'));\n      setLoading(false);\n      return;\n    }\n\n    try {\n      await injectedProvider.send('eth_requestAccounts', []);\n      setShouldConnectMetamask(true);\n    } catch (err) {\n      reportError(err);\n      setShouldConnectMetamask(false);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n\n    return activate(injectedProvider);\n  }, []);\n  useEffect(() => {\n    if (providerOverride) {\n      activate(providerOverride);\n    }\n  }, [providerOverride]);\n  const update = useCallback(newNetwork => {\n    dispatch({\n      type: 'UPDATE_NETWORK',\n      network: newNetwork\n    });\n  }, [network]);\n  const reportError = useCallback(error => {\n    console.error(error);\n    dispatch({\n      type: 'ADD_ERROR',\n      error\n    });\n  }, []);\n  const deactivate = useCallback(() => {\n    setShouldConnectMetamask(false);\n    update({\n      accounts: []\n    });\n  }, []);\n  const onDisconnect = useCallback(error => {\n    deactivate();\n    reportError(error);\n  }, []);\n  useEffect(() => {\n    setTimeout(async () => {\n      var _a, _b, _c;\n\n      try {\n        if (shouldConnectMetamask && autoConnect && !providerOverride) {\n          await detectEthereumProvider(); // If window.ethereum._state.accounts is non null but has no items,\n          // it probably means that the user has disconnected Metamask manually.\n\n          if (shouldConnectMetamask && ((_c = (_b = (_a = window.ethereum) === null || _a === void 0 ? void 0 : _a._state) === null || _b === void 0 ? void 0 : _b.accounts) === null || _c === void 0 ? void 0 : _c.length) === 0) {\n            return;\n          }\n\n          await activateBrowserWallet();\n        }\n      } catch (err) {\n        console.warn(err);\n      }\n    });\n  }, [shouldConnectMetamask, autoConnect, providerOverride]);\n  const activate = useCallback(async provider => {\n    var _a;\n\n    const wrappedProvider = Provider.isProvider(provider) ? provider : new Web3Provider(provider);\n\n    try {\n      setLoading(true);\n      const account = await tryToGetAccount(wrappedProvider);\n      const chainId = (_a = await wrappedProvider.getNetwork()) === null || _a === void 0 ? void 0 : _a.chainId;\n      onUnsubscribe();\n      const clearSubscriptions = subscribeToProviderEvents(wrappedProvider.provider, update, onDisconnect);\n      setOnUnsubscribe(() => clearSubscriptions);\n      update({\n        provider: wrappedProvider,\n        chainId,\n        accounts: account ? [account] : []\n      });\n    } catch (err) {\n      reportError(err);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, [onUnsubscribe]);\n  return _jsx(NetworkContext.Provider, {\n    value: {\n      network,\n      update,\n      activate,\n      deactivate,\n      reportError,\n      activateBrowserWallet,\n      isLoading\n    },\n    children: children\n  });\n}","map":{"version":3,"sources":["../../../../../../src/providers/network/network/provider.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useCallback, useEffect, useReducer, useState } from 'react';\nimport { NetworkContext } from './context';\nimport { defaultNetworkState, networksReducer } from './reducer';\nimport { Web3Provider, Provider } from '@ethersproject/providers';\nimport { subscribeToProviderEvents, getInjectedProvider } from '../../../helpers';\nimport { useConfig } from '../../config';\nimport { useLocalStorage } from '../../../hooks';\nimport detectEthereumProvider from '@metamask/detect-provider';\nasync function tryToGetAccount(provider) {\n    try {\n        return await provider.getSigner().getAddress();\n    }\n    catch (err) {\n        if (err.code === 'UNSUPPORTED_OPERATION') {\n            // readonly provider\n            return undefined;\n        }\n        throw err;\n    }\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function NetworkProvider({ children, providerOverride }) {\n    const { autoConnect, pollingInterval } = useConfig();\n    const [network, dispatch] = useReducer(networksReducer, defaultNetworkState);\n    const [onUnsubscribe, setOnUnsubscribe] = useState(() => () => undefined);\n    const [shouldConnectMetamask, setShouldConnectMetamask] = useLocalStorage('shouldConnectMetamask');\n    const [isLoading, setLoading] = useState(false);\n    const activateBrowserWallet = useCallback(async () => {\n        setLoading(true);\n        const injectedProvider = await getInjectedProvider(pollingInterval);\n        if (!injectedProvider) {\n            reportError(new Error('No injected provider available'));\n            setLoading(false);\n            return;\n        }\n        try {\n            await injectedProvider.send('eth_requestAccounts', []);\n            setShouldConnectMetamask(true);\n        }\n        catch (err) {\n            reportError(err);\n            setShouldConnectMetamask(false);\n            throw err;\n        }\n        finally {\n            setLoading(false);\n        }\n        return activate(injectedProvider);\n    }, []);\n    useEffect(() => {\n        if (providerOverride) {\n            activate(providerOverride);\n        }\n    }, [providerOverride]);\n    const update = useCallback((newNetwork) => {\n        dispatch({ type: 'UPDATE_NETWORK', network: newNetwork });\n    }, [network]);\n    const reportError = useCallback((error) => {\n        console.error(error);\n        dispatch({ type: 'ADD_ERROR', error });\n    }, []);\n    const deactivate = useCallback(() => {\n        setShouldConnectMetamask(false);\n        update({\n            accounts: [],\n        });\n    }, []);\n    const onDisconnect = useCallback((error) => {\n        deactivate();\n        reportError(error);\n    }, []);\n    useEffect(() => {\n        setTimeout(async () => {\n            var _a, _b, _c;\n            try {\n                if (shouldConnectMetamask && autoConnect && !providerOverride) {\n                    await detectEthereumProvider();\n                    // If window.ethereum._state.accounts is non null but has no items,\n                    // it probably means that the user has disconnected Metamask manually.\n                    if (shouldConnectMetamask && ((_c = (_b = (_a = window.ethereum) === null || _a === void 0 ? void 0 : _a._state) === null || _b === void 0 ? void 0 : _b.accounts) === null || _c === void 0 ? void 0 : _c.length) === 0) {\n                        return;\n                    }\n                    await activateBrowserWallet();\n                }\n            }\n            catch (err) {\n                console.warn(err);\n            }\n        });\n    }, [shouldConnectMetamask, autoConnect, providerOverride]);\n    const activate = useCallback(async (provider) => {\n        var _a;\n        const wrappedProvider = Provider.isProvider(provider) ? provider : new Web3Provider(provider);\n        try {\n            setLoading(true);\n            const account = await tryToGetAccount(wrappedProvider);\n            const chainId = (_a = (await wrappedProvider.getNetwork())) === null || _a === void 0 ? void 0 : _a.chainId;\n            onUnsubscribe();\n            const clearSubscriptions = subscribeToProviderEvents(wrappedProvider.provider, update, onDisconnect);\n            setOnUnsubscribe(() => clearSubscriptions);\n            update({\n                provider: wrappedProvider,\n                chainId,\n                accounts: account ? [account] : [],\n            });\n        }\n        catch (err) {\n            reportError(err);\n            throw err;\n        }\n        finally {\n            setLoading(false);\n        }\n    }, [onUnsubscribe]);\n    return (_jsx(NetworkContext.Provider, { value: { network, update, activate, deactivate, reportError, activateBrowserWallet, isLoading }, children: children }));\n}\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}