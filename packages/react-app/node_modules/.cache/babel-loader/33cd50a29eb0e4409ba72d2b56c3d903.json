{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useReducer } from 'react';\nimport { useDebouncePair } from '../../../hooks';\nimport { MultiChainStatesContext } from './context';\nimport { multicall as multicall1, multicall2, useConfig, useNetwork } from '../../..';\nimport { useReadonlyNetworks } from '../../network';\nimport { useBlockNumbers } from '../../blockNumber/blockNumbers';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { performMulticall } from '../common/performMulticall';\nimport { callsReducer, chainStateReducer } from '../common';\nimport { getUniqueCalls } from '../../../helpers';\nimport { useDevtoolsReporting } from '../common/useDevtoolsReporting';\nimport { useChainId } from '../../../hooks/useChainId';\n\nfunction composeChainState(networks, state, multicallAddresses) {\n  return fromEntries(Object.keys(networks).map(chainId => [Number(chainId), {\n    value: state[Number(chainId)],\n    multicallAddress: multicallAddresses[Number(chainId)]\n  }]));\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\n\nexport function MultiChainStateProvider(_ref) {\n  let {\n    children,\n    multicallAddresses\n  } = _ref;\n  const {\n    multicallVersion\n  } = useConfig();\n  const networks = useReadonlyNetworks();\n  const blockNumbers = useBlockNumbers();\n  const {\n    reportError\n  } = useNetwork();\n  const [calls, dispatchCalls] = useReducer(callsReducer, []);\n  const [state, dispatchState] = useReducer(chainStateReducer, {});\n  const multicall = multicallVersion === 1 ? multicall1 : multicall2;\n  const [debouncedCalls, debouncedNetworks] = useDebouncePair(calls, networks, 50);\n  const uniqueCalls = useMemo(() => getUniqueCalls(debouncedCalls), [debouncedCalls]); // used for deep equality in hook dependencies\n\n  const uniqueCallsJSON = JSON.stringify(debouncedCalls);\n  const chainId = useChainId();\n  useDevtoolsReporting(uniqueCallsJSON, uniqueCalls, chainId !== undefined ? blockNumbers[chainId] : undefined, multicallAddresses);\n\n  function multicallForChain(chainId, provider) {\n    const blockNumber = blockNumbers[chainId];\n    const multicallAddress = multicallAddresses[chainId];\n\n    if (!provider || !blockNumber) {\n      return;\n    }\n\n    if (!multicallAddress) {\n      reportError(new Error(`Missing multicall address for chain id ${chainId}`));\n      return;\n    }\n\n    if (debouncedNetworks !== networks) {\n      // Wait for debounce to catch up.\n      return;\n    }\n\n    const callsOnThisChain = uniqueCalls.filter(call => call.chainId === chainId);\n\n    if (callsOnThisChain.length === 0) {\n      return;\n    }\n\n    performMulticall(provider, multicall, multicallAddress, blockNumber, callsOnThisChain, dispatchState, chainId, reportError);\n  }\n\n  useEffect(() => {\n    for (const [_chainId, provider] of Object.entries(networks)) {\n      multicallForChain(Number(_chainId), provider);\n    }\n  }, [blockNumbers, networks, multicallAddresses, uniqueCallsJSON]);\n  const chains = useMemo(() => composeChainState(networks, state, multicallAddresses), [state, multicallAddresses, networks]);\n  const provided = {\n    chains,\n    dispatchCalls\n  };\n  return _jsx(MultiChainStatesContext.Provider, {\n    value: provided,\n    children: children\n  });\n}","map":{"version":3,"sources":["../../../../../../src/providers/chainState/multiChainStates/provider.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useEffect, useMemo, useReducer } from 'react';\nimport { useDebouncePair } from '../../../hooks';\nimport { MultiChainStatesContext } from './context';\nimport { multicall as multicall1, multicall2, useConfig, useNetwork } from '../../..';\nimport { useReadonlyNetworks } from '../../network';\nimport { useBlockNumbers } from '../../blockNumber/blockNumbers';\nimport { fromEntries } from '../../../helpers/fromEntries';\nimport { performMulticall } from '../common/performMulticall';\nimport { callsReducer, chainStateReducer } from '../common';\nimport { getUniqueCalls } from '../../../helpers';\nimport { useDevtoolsReporting } from '../common/useDevtoolsReporting';\nimport { useChainId } from '../../../hooks/useChainId';\nfunction composeChainState(networks, state, multicallAddresses) {\n    return fromEntries(Object.keys(networks).map((chainId) => [\n        Number(chainId),\n        {\n            value: state[Number(chainId)],\n            multicallAddress: multicallAddresses[Number(chainId)],\n        },\n    ]));\n}\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function MultiChainStateProvider({ children, multicallAddresses }) {\n    const { multicallVersion } = useConfig();\n    const networks = useReadonlyNetworks();\n    const blockNumbers = useBlockNumbers();\n    const { reportError } = useNetwork();\n    const [calls, dispatchCalls] = useReducer(callsReducer, []);\n    const [state, dispatchState] = useReducer(chainStateReducer, {});\n    const multicall = multicallVersion === 1 ? multicall1 : multicall2;\n    const [debouncedCalls, debouncedNetworks] = useDebouncePair(calls, networks, 50);\n    const uniqueCalls = useMemo(() => getUniqueCalls(debouncedCalls), [debouncedCalls]);\n    // used for deep equality in hook dependencies\n    const uniqueCallsJSON = JSON.stringify(debouncedCalls);\n    const chainId = useChainId();\n    useDevtoolsReporting(uniqueCallsJSON, uniqueCalls, chainId !== undefined ? blockNumbers[chainId] : undefined, multicallAddresses);\n    function multicallForChain(chainId, provider) {\n        const blockNumber = blockNumbers[chainId];\n        const multicallAddress = multicallAddresses[chainId];\n        if (!provider || !blockNumber) {\n            return;\n        }\n        if (!multicallAddress) {\n            reportError(new Error(`Missing multicall address for chain id ${chainId}`));\n            return;\n        }\n        if (debouncedNetworks !== networks) {\n            // Wait for debounce to catch up.\n            return;\n        }\n        const callsOnThisChain = uniqueCalls.filter((call) => call.chainId === chainId);\n        if (callsOnThisChain.length === 0) {\n            return;\n        }\n        performMulticall(provider, multicall, multicallAddress, blockNumber, callsOnThisChain, dispatchState, chainId, reportError);\n    }\n    useEffect(() => {\n        for (const [_chainId, provider] of Object.entries(networks)) {\n            multicallForChain(Number(_chainId), provider);\n        }\n    }, [blockNumbers, networks, multicallAddresses, uniqueCallsJSON]);\n    const chains = useMemo(() => composeChainState(networks, state, multicallAddresses), [\n        state,\n        multicallAddresses,\n        networks,\n    ]);\n    const provided = { chains, dispatchCalls };\n    return _jsx(MultiChainStatesContext.Provider, { value: provided, children: children });\n}\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}