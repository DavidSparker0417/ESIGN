{"ast":null,"code":"import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useReducer } from 'react';\nimport pickBy from 'lodash.pickby';\nimport { DEFAULT_CONFIG } from '../../model/config/default';\nimport { ConfigContext } from './context';\nimport { configReducer } from './reducer';\n/**\n * We strip supplied config of undefined fields because it can easily break TS assumptions.\n *\n * Illustrative example:\n *\n * type FullConf = { something: string }\n * type PartConf = Partial<FullConf>\n *\n * const defaultConf: FullConf = { something: 'default' }\n * const suppliedConf: PartConf = { something: undefined }\n * const conf: FullConf = {...defaultConf, ...suppliedConf}\n * conf.something.toString() // OK according to TS, breaks on runtime.\n *\n * @internal Intended for internal use - use it on your own risk\n */\n\nconst noUndefined = x => x !== undefined;\n\nexport function ConfigProvider(_ref) {\n  let {\n    config,\n    children\n  } = _ref;\n  const configWithDefaults = Object.assign(Object.assign(Object.assign({}, DEFAULT_CONFIG), pickBy(config, noUndefined)), {\n    notifications: Object.assign(Object.assign({}, DEFAULT_CONFIG.notifications), pickBy(config.notifications, noUndefined))\n  });\n  const [reducedConfig, dispatch] = useReducer(configReducer, configWithDefaults);\n  return _jsx(ConfigContext.Provider, {\n    value: {\n      config: reducedConfig,\n      updateConfig: dispatch\n    },\n    children: children\n  });\n}","map":{"version":3,"sources":["../../../../../src/providers/config/provider.tsx"],"names":[],"mappings":";AAAA,SAAoB,UAApB,QAAsC,OAAtC;AACA,OAAO,MAAP,MAAmB,eAAnB;AAEA,SAAS,cAAT,QAA+B,4BAA/B;AACA,SAAS,aAAT,QAA8B,WAA9B;AACA,SAAS,aAAT,QAA8B,WAA9B;AAOA;;;;;;;;;;;;;;AAcG;;AACH,MAAM,WAAW,GAAI,CAAD,IAAY,CAAC,KAAK,SAAtC;;AACA,OAAM,SAAU,cAAV,OAAkE;EAAA,IAAzC;IAAE,MAAF;IAAU;EAAV,CAAyC;EACtE,MAAM,kBAAkB,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACnB,cADmB,CAAA,EAEnB,MAAM,CAAC,MAAD,EAAS,WAAT,CAFa,CAAA,EAEQ;IAC9B,aAAa,EAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACR,cAAc,CAAC,aADP,CAAA,EAER,MAAM,CAAC,MAAM,CAAC,aAAR,EAAuB,WAAvB,CAFE;EADiB,CAFR,CAAxB;EAQA,MAAM,CAAC,aAAD,EAAgB,QAAhB,IAA4B,UAAU,CAAC,aAAD,EAAgB,kBAAhB,CAA5C;EACA,OAAO,IAAA,CAAC,aAAa,CAAC,QAAf,EAAuB;IAAC,KAAK,EAAE;MAAE,MAAM,EAAE,aAAV;MAAyB,YAAY,EAAE;IAAvC,CAAR;IAA2D,QAAQ,EAAE;EAArE,CAAvB,CAAP;AACD","sourceRoot":"","sourcesContent":["import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { useReducer } from 'react';\nimport pickBy from 'lodash.pickby';\nimport { DEFAULT_CONFIG } from '../../model/config/default';\nimport { ConfigContext } from './context';\nimport { configReducer } from './reducer';\n/**\n * We strip supplied config of undefined fields because it can easily break TS assumptions.\n *\n * Illustrative example:\n *\n * type FullConf = { something: string }\n * type PartConf = Partial<FullConf>\n *\n * const defaultConf: FullConf = { something: 'default' }\n * const suppliedConf: PartConf = { something: undefined }\n * const conf: FullConf = {...defaultConf, ...suppliedConf}\n * conf.something.toString() // OK according to TS, breaks on runtime.\n *\n * @internal Intended for internal use - use it on your own risk\n */\nconst noUndefined = (x) => x !== undefined;\nexport function ConfigProvider({ config, children }) {\n    const configWithDefaults = Object.assign(Object.assign(Object.assign({}, DEFAULT_CONFIG), pickBy(config, noUndefined)), { notifications: Object.assign(Object.assign({}, DEFAULT_CONFIG.notifications), pickBy(config.notifications, noUndefined)) });\n    const [reducedConfig, dispatch] = useReducer(configReducer, configWithDefaults);\n    return _jsx(ConfigContext.Provider, { value: { config: reducedConfig, updateConfig: dispatch }, children: children });\n}\n//# sourceMappingURL=provider.js.map"]},"metadata":{},"sourceType":"module"}