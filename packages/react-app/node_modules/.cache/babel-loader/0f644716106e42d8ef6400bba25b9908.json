{"ast":null,"code":"// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nvar defaultMakeData = function () {\n  return Object.create(null);\n}; // Useful for processing arguments objects as well as arrays.\n\n\nvar _a = Array.prototype,\n    forEach = _a.forEach,\n    slice = _a.slice;\n\nvar Trie =\n/** @class */\nfunction () {\n  function Trie(weakness, makeData) {\n    if (weakness === void 0) {\n      weakness = true;\n    }\n\n    if (makeData === void 0) {\n      makeData = defaultMakeData;\n    }\n\n    this.weakness = weakness;\n    this.makeData = makeData;\n  }\n\n  Trie.prototype.lookup = function () {\n    var array = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      array[_i] = arguments[_i];\n    }\n\n    return this.lookupArray(array);\n  };\n\n  Trie.prototype.lookupArray = function (array) {\n    var node = this;\n    forEach.call(array, function (key) {\n      return node = node.getChildTrie(key);\n    });\n    return node.data || (node.data = this.makeData(slice.call(array)));\n  };\n\n  Trie.prototype.getChildTrie = function (key) {\n    var map = this.weakness && isObjRef(key) ? this.weak || (this.weak = new WeakMap()) : this.strong || (this.strong = new Map());\n    var child = map.get(key);\n    if (!child) map.set(key, child = new Trie(this.weakness, this.makeData));\n    return child;\n  };\n\n  return Trie;\n}();\n\nfunction isObjRef(value) {\n  switch (typeof value) {\n    case \"object\":\n      if (value === null) break;\n    // Fall through to return true...\n\n    case \"function\":\n      return true;\n  }\n\n  return false;\n}\n\nexport { Trie };","map":{"version":3,"sources":["../src/trie.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AAEA;AACA;AACA,IAAM,eAAe,GAAG,YAAA;EAAM,OAAA,MAAM,CAAC,MAAP,CAAc,IAAd,CAAA;AAAmB,CAAjD,C,CAEA;;;AACM,IAAA,EAAA,GAAqB,KAAK,CAAC,SAA3B;AAAA,IAAE,OAAO,GAAA,EAAA,CAAA,OAAT;AAAA,IAAW,KAAK,GAAA,EAAA,CAAA,KAAhB;;;;;EAUJ,SAAA,IAAA,CACU,QADV,EAEU,QAFV,EAE4D;IADlD,IAAA,QAAA,KAAA,KAAA,CAAA,EAAA;MAAA,QAAA,GAAA,IAAA;IAAe;;IACf,IAAA,QAAA,KAAA,KAAA,CAAA,EAAA;MAAA,QAAA,GAAA,eAAA;IAAkD;;IADlD,KAAA,QAAA,GAAA,QAAA;IACA,KAAA,QAAA,GAAA,QAAA;EACN;;EAEG,IAAA,CAAA,SAAA,CAAA,MAAA,GAAP,YAAA;IAA+B,IAAA,KAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAW;MAAX,KAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;IAC7B,OAAO,KAAK,WAAL,CAAiB,KAAjB,CAAP;EACD,CAFM;;EAIA,IAAA,CAAA,SAAA,CAAA,WAAA,GAAP,UAAiD,KAAjD,EAAyD;IACvD,IAAI,IAAI,GAAe,IAAvB;IACA,OAAO,CAAC,IAAR,CAAa,KAAb,EAAoB,UAAA,GAAA,EAAG;MAAI,OAAA,IAAI,GAAG,IAAI,CAAC,YAAL,CAAkB,GAAlB,CAAP;IAA6B,CAAxD;IACA,OAAO,IAAI,CAAC,IAAL,KAAc,IAAI,CAAC,IAAL,GAAY,KAAK,QAAL,CAAc,KAAK,CAAC,IAAN,CAAW,KAAX,CAAd,CAA1B,CAAP;EACD,CAJM;;EAMC,IAAA,CAAA,SAAA,CAAA,YAAA,GAAR,UAAqB,GAArB,EAA6B;IAC3B,IAAM,GAAG,GAAG,KAAK,QAAL,IAAiB,QAAQ,CAAC,GAAD,CAAzB,GACR,KAAK,IAAL,KAAc,KAAK,IAAL,GAAY,IAAI,OAAJ,EAA1B,CADQ,GAER,KAAK,MAAL,KAAgB,KAAK,MAAL,GAAc,IAAI,GAAJ,EAA9B,CAFJ;IAGA,IAAI,KAAK,GAAG,GAAG,CAAC,GAAJ,CAAQ,GAAR,CAAZ;IACA,IAAI,CAAC,KAAL,EAAY,GAAG,CAAC,GAAJ,CAAQ,GAAR,EAAa,KAAK,GAAG,IAAI,IAAJ,CAAe,KAAK,QAApB,EAA8B,KAAK,QAAnC,CAArB;IACZ,OAAO,KAAP;EACD,CAPO;;EAQV,OAAA,IAAA;AAAC,C;;AAED,SAAS,QAAT,CAAkB,KAAlB,EAA4B;EAC1B,QAAQ,OAAO,KAAf;IACA,KAAK,QAAL;MACE,IAAI,KAAK,KAAK,IAAd,EAAoB;;;IAEtB,KAAK,UAAL;MACE,OAAO,IAAP;EALF;;EAOA,OAAO,KAAP;AACF","sourcesContent":["// A [trie](https://en.wikipedia.org/wiki/Trie) data structure that holds\n// object keys weakly, yet can also hold non-object keys, unlike the\n// native `WeakMap`.\n\n// If no makeData function is supplied, the looked-up data will be an empty,\n// null-prototype Object.\nconst defaultMakeData = () => Object.create(null);\n\n// Useful for processing arguments objects as well as arrays.\nconst { forEach, slice } = Array.prototype;\n\nexport class Trie<Data> {\n  // Since a `WeakMap` cannot hold primitive values as keys, we need a\n  // backup `Map` instance to hold primitive keys. Both `this._weakMap`\n  // and `this._strongMap` are lazily initialized.\n  private weak?: WeakMap<any, Trie<Data>>;\n  private strong?: Map<any, Trie<Data>>;\n  private data?: Data;\n\n  constructor(\n    private weakness = true,\n    private makeData: (array: any[]) => Data = defaultMakeData,\n  ) {}\n\n  public lookup<T extends any[]>(...array: T): Data {\n    return this.lookupArray(array);\n  }\n\n  public lookupArray<T extends IArguments | any[]>(array: T): Data {\n    let node: Trie<Data> = this;\n    forEach.call(array, key => node = node.getChildTrie(key));\n    return node.data || (node.data = this.makeData(slice.call(array)));\n  }\n\n  private getChildTrie(key: any) {\n    const map = this.weakness && isObjRef(key)\n      ? this.weak || (this.weak = new WeakMap<any, Trie<Data>>())\n      : this.strong || (this.strong = new Map<any, Trie<Data>>());\n    let child = map.get(key);\n    if (!child) map.set(key, child = new Trie<Data>(this.weakness, this.makeData));\n    return child;\n  }\n}\n\nfunction isObjRef(value: any) {\n  switch (typeof value) {\n  case \"object\":\n    if (value === null) break;\n    // Fall through to return true...\n  case \"function\":\n    return true;\n  }\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}