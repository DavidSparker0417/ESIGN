{"ast":null,"code":"import { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { usePromiseTransaction } from './usePromiseTransaction';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\n\nexport function connectContractToSigner(contract, options, library) {\n  if (contract.signer) {\n    return contract;\n  }\n\n  if (options === null || options === void 0 ? void 0 : options.signer) {\n    return contract.connect(options.signer);\n  }\n\n  if (library === null || library === void 0 ? void 0 : library.getSigner()) {\n    return contract.connect(library.getSigner());\n  }\n\n  throw new TypeError('No signer available in contract, options or library');\n}\n/**\n * @public\n */\n\nexport function useContractFunction(contract, functionName, options) {\n  const {\n    library,\n    chainId\n  } = useEthers();\n  const {\n    promiseTransaction,\n    state,\n    resetState\n  } = usePromiseTransaction(chainId, options);\n  const [events, setEvents] = useState(undefined);\n  const send = useCallback(async function () {\n    const contractWithSigner = connectContractToSigner(contract, options, library);\n    const receipt = await promiseTransaction(contractWithSigner[functionName](...arguments));\n\n    if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n      const events = receipt.logs.reduce((accumulatedLogs, log) => {\n        try {\n          return log.address.toLowerCase() === contract.address.toLowerCase() ? [...accumulatedLogs, contract.interface.parseLog(log)] : accumulatedLogs;\n        } catch (_err) {\n          return accumulatedLogs;\n        }\n      }, []);\n      setEvents(events);\n    }\n  }, [contract, functionName, options, library]);\n  return {\n    send,\n    state,\n    events,\n    resetState\n  };\n}","map":{"version":3,"sources":["../../../../src/hooks/useContractFunction.ts"],"names":[],"mappings":"AAGA,SAAS,WAAT,EAAsB,QAAtB,QAAsC,OAAtC;AACA,SAAS,SAAT,QAA0B,aAA1B;AACA,SAAS,qBAAT,QAAsC,yBAAtC;AAIA;;AAEG;;AACH,OAAM,SAAU,uBAAV,CAAkC,QAAlC,EAAsD,OAAtD,EAAoF,OAApF,EAA6G;EACjH,IAAI,QAAQ,CAAC,MAAb,EAAqB;IACnB,OAAO,QAAP;EACD;;EAED,IAAI,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,MAAb,EAAqB;IACnB,OAAO,QAAQ,CAAC,OAAT,CAAiB,OAAO,CAAC,MAAzB,CAAP;EACD;;EAED,IAAI,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,SAAT,EAAJ,EAA0B;IACxB,OAAO,QAAQ,CAAC,OAAT,CAAiB,OAAO,CAAC,SAAR,EAAjB,CAAP;EACD;;EAED,MAAM,IAAI,SAAJ,CAAc,qDAAd,CAAN;AACD;AAED;;AAEG;;AACH,OAAM,SAAU,mBAAV,CACJ,QADI,EAEJ,YAFI,EAGJ,OAHI,EAGwB;EAE5B,MAAM;IAAE,OAAF;IAAW;EAAX,IAAuB,SAAS,EAAtC;EACA,MAAM;IAAE,kBAAF;IAAsB,KAAtB;IAA6B;EAA7B,IAA4C,qBAAqB,CAAC,OAAD,EAAU,OAAV,CAAvE;EACA,MAAM,CAAC,MAAD,EAAS,SAAT,IAAsB,QAAQ,CAA+B,SAA/B,CAApC;EAEA,MAAM,IAAI,GAAG,WAAW,CACtB,kBAAgD;IAC9C,MAAM,kBAAkB,GAAG,uBAAuB,CAAC,QAAD,EAAW,OAAX,EAAoB,OAApB,CAAlD;IACA,MAAM,OAAO,GAAG,MAAM,kBAAkB,CAAC,kBAAkB,CAAC,YAAD,CAAlB,CAAiC,YAAjC,CAAD,CAAxC;;IACA,IAAI,OAAO,KAAA,IAAP,IAAA,OAAO,KAAA,KAAA,CAAP,GAAO,KAAA,CAAP,GAAA,OAAO,CAAE,IAAb,EAAmB;MACjB,MAAM,MAAM,GAAG,OAAO,CAAC,IAAR,CAAa,MAAb,CAAoB,CAAC,eAAD,EAAkB,GAAlB,KAAyB;QAC1D,IAAI;UACF,OAAO,GAAG,CAAC,OAAJ,CAAY,WAAZ,OAA8B,QAAQ,CAAC,OAAT,CAAiB,WAAjB,EAA9B,GACH,CAAC,GAAG,eAAJ,EAAqB,QAAQ,CAAC,SAAT,CAAmB,QAAnB,CAA4B,GAA5B,CAArB,CADG,GAEH,eAFJ;QAGD,CAJD,CAIE,OAAO,IAAP,EAAa;UACb,OAAO,eAAP;QACD;MACF,CARc,EAQZ,EARY,CAAf;MASA,SAAS,CAAC,MAAD,CAAT;IACD;EACF,CAhBqB,EAiBtB,CAAC,QAAD,EAAW,YAAX,EAAyB,OAAzB,EAAkC,OAAlC,CAjBsB,CAAxB;EAoBA,OAAO;IAAE,IAAF;IAAQ,KAAR;IAAe,MAAf;IAAuB;EAAvB,CAAP;AACD","sourceRoot":"","sourcesContent":["import { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { usePromiseTransaction } from './usePromiseTransaction';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function connectContractToSigner(contract, options, library) {\n    if (contract.signer) {\n        return contract;\n    }\n    if (options === null || options === void 0 ? void 0 : options.signer) {\n        return contract.connect(options.signer);\n    }\n    if (library === null || library === void 0 ? void 0 : library.getSigner()) {\n        return contract.connect(library.getSigner());\n    }\n    throw new TypeError('No signer available in contract, options or library');\n}\n/**\n * @public\n */\nexport function useContractFunction(contract, functionName, options) {\n    const { library, chainId } = useEthers();\n    const { promiseTransaction, state, resetState } = usePromiseTransaction(chainId, options);\n    const [events, setEvents] = useState(undefined);\n    const send = useCallback(async (...args) => {\n        const contractWithSigner = connectContractToSigner(contract, options, library);\n        const receipt = await promiseTransaction(contractWithSigner[functionName](...args));\n        if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n            const events = receipt.logs.reduce((accumulatedLogs, log) => {\n                try {\n                    return log.address.toLowerCase() === contract.address.toLowerCase()\n                        ? [...accumulatedLogs, contract.interface.parseLog(log)]\n                        : accumulatedLogs;\n                }\n                catch (_err) {\n                    return accumulatedLogs;\n                }\n            }, []);\n            setEvents(events);\n        }\n    }, [contract, functionName, options, library]);\n    return { send, state, events, resetState };\n}\n//# sourceMappingURL=useContractFunction.js.map"]},"metadata":{},"sourceType":"module"}