{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { invariant } from \"../utilities/globals/index.js\";\nimport { visit, BREAK } from 'graphql';\nimport { argumentsObjectFromField, buildQueryFromSelectionSet, createFragmentMap, getFragmentDefinitions, getMainDefinition, hasDirectives, isField, isInlineFragment, mergeDeep, mergeDeepArray, removeClientSetsFromDocument, resultKeyNameFromField, shouldInclude } from \"../utilities/index.js\";\nimport { cacheSlot } from \"../cache/index.js\";\n\nvar LocalState = function () {\n  function LocalState(_a) {\n    var cache = _a.cache,\n        client = _a.client,\n        resolvers = _a.resolvers,\n        fragmentMatcher = _a.fragmentMatcher;\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  LocalState.prototype.addResolvers = function (resolvers) {\n    var _this = this;\n\n    this.resolvers = this.resolvers || {};\n\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(function (resolverGroup) {\n        _this.resolvers = mergeDeep(_this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  };\n\n  LocalState.prototype.setResolvers = function (resolvers) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  };\n\n  LocalState.prototype.getResolvers = function () {\n    return this.resolvers || {};\n  };\n\n  LocalState.prototype.runResolvers = function (_a) {\n    var document = _a.document,\n        remoteResult = _a.remoteResult,\n        context = _a.context,\n        variables = _a.variables,\n        _b = _a.onlyRunForcedResolvers,\n        onlyRunForcedResolvers = _b === void 0 ? false : _b;\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_c) {\n        if (document) {\n          return [2, this.resolveDocument(document, remoteResult.data, context, variables, this.fragmentMatcher, onlyRunForcedResolvers).then(function (localResult) {\n            return __assign(__assign({}, remoteResult), {\n              data: localResult.result\n            });\n          })];\n        }\n\n        return [2, remoteResult];\n      });\n    });\n  };\n\n  LocalState.prototype.setFragmentMatcher = function (fragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  };\n\n  LocalState.prototype.getFragmentMatcher = function () {\n    return this.fragmentMatcher;\n  };\n\n  LocalState.prototype.clientQuery = function (document) {\n    if (hasDirectives(['client'], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n\n    return null;\n  };\n\n  LocalState.prototype.serverQuery = function (document) {\n    return removeClientSetsFromDocument(document);\n  };\n\n  LocalState.prototype.prepareContext = function (context) {\n    var cache = this.cache;\n    return __assign(__assign({}, context), {\n      cache: cache,\n      getCacheKey: function (obj) {\n        return cache.identify(obj);\n      }\n    });\n  };\n\n  LocalState.prototype.addExportedVariables = function (document, variables, context) {\n    if (variables === void 0) {\n      variables = {};\n    }\n\n    if (context === void 0) {\n      context = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        if (document) {\n          return [2, this.resolveDocument(document, this.buildRootValueFromCache(document, variables) || {}, this.prepareContext(context), variables).then(function (data) {\n            return __assign(__assign({}, variables), data.exportedVariables);\n          })];\n        }\n\n        return [2, __assign({}, variables)];\n      });\n    });\n  };\n\n  LocalState.prototype.shouldForceResolvers = function (document) {\n    var forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter: function (node) {\n          if (node.name.value === 'client' && node.arguments) {\n            forceResolvers = node.arguments.some(function (arg) {\n              return arg.name.value === 'always' && arg.value.kind === 'BooleanValue' && arg.value.value === true;\n            });\n\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        }\n      }\n    });\n    return forceResolvers;\n  };\n\n  LocalState.prototype.buildRootValueFromCache = function (document, variables) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables: variables,\n      returnPartialData: true,\n      optimistic: false\n    }).result;\n  };\n\n  LocalState.prototype.resolveDocument = function (document, rootValue, context, variables, fragmentMatcher, onlyRunForcedResolvers) {\n    if (context === void 0) {\n      context = {};\n    }\n\n    if (variables === void 0) {\n      variables = {};\n    }\n\n    if (fragmentMatcher === void 0) {\n      fragmentMatcher = function () {\n        return true;\n      };\n    }\n\n    if (onlyRunForcedResolvers === void 0) {\n      onlyRunForcedResolvers = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var mainDefinition, fragments, fragmentMap, definitionOperation, defaultOperationType, _a, cache, client, execContext;\n\n      return __generator(this, function (_b) {\n        mainDefinition = getMainDefinition(document);\n        fragments = getFragmentDefinitions(document);\n        fragmentMap = createFragmentMap(fragments);\n        definitionOperation = mainDefinition.operation;\n        defaultOperationType = definitionOperation ? definitionOperation.charAt(0).toUpperCase() + definitionOperation.slice(1) : 'Query';\n        _a = this, cache = _a.cache, client = _a.client;\n        execContext = {\n          fragmentMap: fragmentMap,\n          context: __assign(__assign({}, context), {\n            cache: cache,\n            client: client\n          }),\n          variables: variables,\n          fragmentMatcher: fragmentMatcher,\n          defaultOperationType: defaultOperationType,\n          exportedVariables: {},\n          onlyRunForcedResolvers: onlyRunForcedResolvers\n        };\n        return [2, this.resolveSelectionSet(mainDefinition.selectionSet, rootValue, execContext).then(function (result) {\n          return {\n            result: result,\n            exportedVariables: execContext.exportedVariables\n          };\n        })];\n      });\n    });\n  };\n\n  LocalState.prototype.resolveSelectionSet = function (selectionSet, rootValue, execContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var fragmentMap, context, variables, resultsToMerge, execute;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        fragmentMap = execContext.fragmentMap, context = execContext.context, variables = execContext.variables;\n        resultsToMerge = [rootValue];\n\n        execute = function (selection) {\n          return __awaiter(_this, void 0, void 0, function () {\n            var fragment, typeCondition;\n            return __generator(this, function (_a) {\n              if (!shouldInclude(selection, variables)) {\n                return [2];\n              }\n\n              if (isField(selection)) {\n                return [2, this.resolveField(selection, rootValue, execContext).then(function (fieldResult) {\n                  var _a;\n\n                  if (typeof fieldResult !== 'undefined') {\n                    resultsToMerge.push((_a = {}, _a[resultKeyNameFromField(selection)] = fieldResult, _a));\n                  }\n                })];\n              }\n\n              if (isInlineFragment(selection)) {\n                fragment = selection;\n              } else {\n                fragment = fragmentMap[selection.name.value];\n                __DEV__ ? invariant(fragment, \"No fragment named \".concat(selection.name.value)) : invariant(fragment, 9);\n              }\n\n              if (fragment && fragment.typeCondition) {\n                typeCondition = fragment.typeCondition.name.value;\n\n                if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n                  return [2, this.resolveSelectionSet(fragment.selectionSet, rootValue, execContext).then(function (fragmentResult) {\n                    resultsToMerge.push(fragmentResult);\n                  })];\n                }\n              }\n\n              return [2];\n            });\n          });\n        };\n\n        return [2, Promise.all(selectionSet.selections.map(execute)).then(function () {\n          return mergeDeepArray(resultsToMerge);\n        })];\n      });\n    });\n  };\n\n  LocalState.prototype.resolveField = function (field, rootValue, execContext) {\n    return __awaiter(this, void 0, void 0, function () {\n      var variables, fieldName, aliasedFieldName, aliasUsed, defaultResult, resultPromise, resolverType, resolverMap, resolve;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        variables = execContext.variables;\n        fieldName = field.name.value;\n        aliasedFieldName = resultKeyNameFromField(field);\n        aliasUsed = fieldName !== aliasedFieldName;\n        defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n        resultPromise = Promise.resolve(defaultResult);\n\n        if (!execContext.onlyRunForcedResolvers || this.shouldForceResolvers(field)) {\n          resolverType = rootValue.__typename || execContext.defaultOperationType;\n          resolverMap = this.resolvers && this.resolvers[resolverType];\n\n          if (resolverMap) {\n            resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n\n            if (resolve) {\n              resultPromise = Promise.resolve(cacheSlot.withValue(this.cache, resolve, [rootValue, argumentsObjectFromField(field, variables), execContext.context, {\n                field: field,\n                fragmentMap: execContext.fragmentMap\n              }]));\n            }\n          }\n        }\n\n        return [2, resultPromise.then(function (result) {\n          if (result === void 0) {\n            result = defaultResult;\n          }\n\n          if (field.directives) {\n            field.directives.forEach(function (directive) {\n              if (directive.name.value === 'export' && directive.arguments) {\n                directive.arguments.forEach(function (arg) {\n                  if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                    execContext.exportedVariables[arg.value.value] = result;\n                  }\n                });\n              }\n            });\n          }\n\n          if (!field.selectionSet) {\n            return result;\n          }\n\n          if (result == null) {\n            return result;\n          }\n\n          if (Array.isArray(result)) {\n            return _this.resolveSubSelectedArray(field, result, execContext);\n          }\n\n          if (field.selectionSet) {\n            return _this.resolveSelectionSet(field.selectionSet, result, execContext);\n          }\n        })];\n      });\n    });\n  };\n\n  LocalState.prototype.resolveSubSelectedArray = function (field, result, execContext) {\n    var _this = this;\n\n    return Promise.all(result.map(function (item) {\n      if (item === null) {\n        return null;\n      }\n\n      if (Array.isArray(item)) {\n        return _this.resolveSubSelectedArray(field, item, execContext);\n      }\n\n      if (field.selectionSet) {\n        return _this.resolveSelectionSet(field.selectionSet, item, execContext);\n      }\n    }));\n  };\n\n  return LocalState;\n}();\n\nexport { LocalState };","map":{"version":3,"sources":["../../src/core/LocalState.ts"],"names":[],"mappings":"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","sourcesContent":["import { invariant } from '../utilities/globals';\n\nimport {\n  DocumentNode,\n  OperationDefinitionNode,\n  SelectionSetNode,\n  SelectionNode,\n  InlineFragmentNode,\n  FragmentDefinitionNode,\n  FieldNode,\n  ASTNode,\n  visit,\n  BREAK,\n} from 'graphql';\n\nimport { ApolloCache } from '../cache';\nimport {\n  FragmentMap,\n  StoreObject,\n  argumentsObjectFromField,\n  buildQueryFromSelectionSet,\n  createFragmentMap,\n  getFragmentDefinitions,\n  getMainDefinition,\n  hasDirectives,\n  isField,\n  isInlineFragment,\n  mergeDeep,\n  mergeDeepArray,\n  removeClientSetsFromDocument,\n  resultKeyNameFromField,\n  shouldInclude,\n} from '../utilities';\nimport { ApolloClient } from './ApolloClient';\nimport { Resolvers, OperationVariables } from './types';\nimport { FetchResult } from '../link/core';\nimport { cacheSlot } from '../cache';\n\nexport type Resolver = (\n  rootValue?: any,\n  args?: any,\n  context?: any,\n  info?: {\n    field: FieldNode;\n    fragmentMap: FragmentMap;\n  },\n) => any;\n\nexport type VariableMap = { [name: string]: any };\n\nexport type FragmentMatcher = (\n  rootValue: any,\n  typeCondition: string,\n  context: any,\n) => boolean;\n\nexport type ExecContext = {\n  fragmentMap: FragmentMap;\n  context: any;\n  variables: VariableMap;\n  fragmentMatcher: FragmentMatcher;\n  defaultOperationType: string;\n  exportedVariables: Record<string, any>;\n  onlyRunForcedResolvers: boolean;\n};\n\nexport type LocalStateOptions<TCacheShape> = {\n  cache: ApolloCache<TCacheShape>;\n  client?: ApolloClient<TCacheShape>;\n  resolvers?: Resolvers | Resolvers[];\n  fragmentMatcher?: FragmentMatcher;\n};\n\nexport class LocalState<TCacheShape> {\n  private cache: ApolloCache<TCacheShape>;\n  private client: ApolloClient<TCacheShape>;\n  private resolvers?: Resolvers;\n  private fragmentMatcher: FragmentMatcher;\n\n  constructor({\n    cache,\n    client,\n    resolvers,\n    fragmentMatcher,\n  }: LocalStateOptions<TCacheShape>) {\n    this.cache = cache;\n\n    if (client) {\n      this.client = client;\n    }\n\n    if (resolvers) {\n      this.addResolvers(resolvers);\n    }\n\n    if (fragmentMatcher) {\n      this.setFragmentMatcher(fragmentMatcher);\n    }\n  }\n\n  public addResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = this.resolvers || {};\n    if (Array.isArray(resolvers)) {\n      resolvers.forEach(resolverGroup => {\n        this.resolvers = mergeDeep(this.resolvers, resolverGroup);\n      });\n    } else {\n      this.resolvers = mergeDeep(this.resolvers, resolvers);\n    }\n  }\n\n  public setResolvers(resolvers: Resolvers | Resolvers[]) {\n    this.resolvers = {};\n    this.addResolvers(resolvers);\n  }\n\n  public getResolvers() {\n    return this.resolvers || {};\n  }\n\n  // Run local client resolvers against the incoming query and remote data.\n  // Locally resolved field values are merged with the incoming remote data,\n  // and returned. Note that locally resolved fields will overwrite\n  // remote data using the same field name.\n  public async runResolvers<TData>({\n    document,\n    remoteResult,\n    context,\n    variables,\n    onlyRunForcedResolvers = false,\n  }: {\n    document: DocumentNode | null;\n    remoteResult: FetchResult<TData>;\n    context?: Record<string, any>;\n    variables?: Record<string, any>;\n    onlyRunForcedResolvers?: boolean;\n  }): Promise<FetchResult<TData>> {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        remoteResult.data,\n        context,\n        variables,\n        this.fragmentMatcher,\n        onlyRunForcedResolvers,\n      ).then(localResult => ({\n        ...remoteResult,\n        data: localResult.result,\n      }));\n    }\n\n    return remoteResult;\n  }\n\n  public setFragmentMatcher(fragmentMatcher: FragmentMatcher) {\n    this.fragmentMatcher = fragmentMatcher;\n  }\n\n  public getFragmentMatcher(): FragmentMatcher {\n    return this.fragmentMatcher;\n  }\n\n  // Client queries contain everything in the incoming document (if a @client\n  // directive is found).\n  public clientQuery(document: DocumentNode) {\n    if (hasDirectives(['client'], document)) {\n      if (this.resolvers) {\n        return document;\n      }\n    }\n    return null;\n  }\n\n  // Server queries are stripped of all @client based selection sets.\n  public serverQuery(document: DocumentNode) {\n    return removeClientSetsFromDocument(document);\n  }\n\n  public prepareContext(context?: Record<string, any>) {\n    const { cache } = this;\n    return {\n      ...context,\n      cache,\n      // Getting an entry's cache key is useful for local state resolvers.\n      getCacheKey(obj: StoreObject) {\n        return cache.identify(obj);\n      },\n    };\n  }\n\n  // To support `@client @export(as: \"someVar\")` syntax, we'll first resolve\n  // @client @export fields locally, then pass the resolved values back to be\n  // used alongside the original operation variables.\n  public async addExportedVariables(\n    document: DocumentNode,\n    variables: OperationVariables = {},\n    context = {},\n  ) {\n    if (document) {\n      return this.resolveDocument(\n        document,\n        this.buildRootValueFromCache(document, variables) || {},\n        this.prepareContext(context),\n        variables,\n      ).then(data => ({\n        ...variables,\n        ...data.exportedVariables,\n      }));\n    }\n\n    return {\n      ...variables,\n    };\n  }\n\n  public shouldForceResolvers(document: ASTNode) {\n    let forceResolvers = false;\n    visit(document, {\n      Directive: {\n        enter(node) {\n          if (node.name.value === 'client' && node.arguments) {\n            forceResolvers = node.arguments.some(\n              arg =>\n                arg.name.value === 'always' &&\n                arg.value.kind === 'BooleanValue' &&\n                arg.value.value === true,\n            );\n            if (forceResolvers) {\n              return BREAK;\n            }\n          }\n        },\n      },\n    });\n    return forceResolvers;\n  }\n\n  // Query the cache and return matching data.\n  private buildRootValueFromCache(\n    document: DocumentNode,\n    variables?: Record<string, any>,\n  ) {\n    return this.cache.diff({\n      query: buildQueryFromSelectionSet(document),\n      variables,\n      returnPartialData: true,\n      optimistic: false,\n    }).result;\n  }\n\n  private async resolveDocument<TData>(\n    document: DocumentNode,\n    rootValue: TData,\n    context: any = {},\n    variables: VariableMap = {},\n    fragmentMatcher: FragmentMatcher = () => true,\n    onlyRunForcedResolvers: boolean = false,\n  ) {\n    const mainDefinition = getMainDefinition(document);\n    const fragments = getFragmentDefinitions(document);\n    const fragmentMap = createFragmentMap(fragments);\n\n    const definitionOperation = (mainDefinition as OperationDefinitionNode)\n      .operation;\n\n    const defaultOperationType = definitionOperation\n      ? definitionOperation.charAt(0).toUpperCase() +\n        definitionOperation.slice(1)\n      : 'Query';\n\n    const { cache, client } = this;\n    const execContext: ExecContext = {\n      fragmentMap,\n      context: {\n        ...context,\n        cache,\n        client,\n      },\n      variables,\n      fragmentMatcher,\n      defaultOperationType,\n      exportedVariables: {},\n      onlyRunForcedResolvers,\n    };\n\n    return this.resolveSelectionSet(\n      mainDefinition.selectionSet,\n      rootValue,\n      execContext,\n    ).then(result => ({\n      result,\n      exportedVariables: execContext.exportedVariables,\n    }));\n  }\n\n  private async resolveSelectionSet<TData>(\n    selectionSet: SelectionSetNode,\n    rootValue: TData,\n    execContext: ExecContext,\n  ) {\n    const { fragmentMap, context, variables } = execContext;\n    const resultsToMerge: TData[] = [rootValue];\n\n    const execute = async (selection: SelectionNode): Promise<void> => {\n      if (!shouldInclude(selection, variables)) {\n        // Skip this entirely.\n        return;\n      }\n\n      if (isField(selection)) {\n        return this.resolveField(selection, rootValue, execContext).then(\n          fieldResult => {\n            if (typeof fieldResult !== 'undefined') {\n              resultsToMerge.push({\n                [resultKeyNameFromField(selection)]: fieldResult,\n              } as TData);\n            }\n          },\n        );\n      }\n\n      let fragment: InlineFragmentNode | FragmentDefinitionNode;\n\n      if (isInlineFragment(selection)) {\n        fragment = selection;\n      } else {\n        // This is a named fragment.\n        fragment = fragmentMap[selection.name.value];\n        invariant(fragment, `No fragment named ${selection.name.value}`);\n      }\n\n      if (fragment && fragment.typeCondition) {\n        const typeCondition = fragment.typeCondition.name.value;\n        if (execContext.fragmentMatcher(rootValue, typeCondition, context)) {\n          return this.resolveSelectionSet(\n            fragment.selectionSet,\n            rootValue,\n            execContext,\n          ).then(fragmentResult => {\n            resultsToMerge.push(fragmentResult);\n          });\n        }\n      }\n    };\n\n    return Promise.all(selectionSet.selections.map(execute)).then(function() {\n      return mergeDeepArray(resultsToMerge);\n    });\n  }\n\n  private async resolveField(\n    field: FieldNode,\n    rootValue: any,\n    execContext: ExecContext,\n  ): Promise<any> {\n    const { variables } = execContext;\n    const fieldName = field.name.value;\n    const aliasedFieldName = resultKeyNameFromField(field);\n    const aliasUsed = fieldName !== aliasedFieldName;\n    const defaultResult = rootValue[aliasedFieldName] || rootValue[fieldName];\n    let resultPromise = Promise.resolve(defaultResult);\n\n    // Usually all local resolvers are run when passing through here, but\n    // if we've specifically identified that we only want to run forced\n    // resolvers (that is, resolvers for fields marked with\n    // `@client(always: true)`), then we'll skip running non-forced resolvers.\n    if (\n      !execContext.onlyRunForcedResolvers ||\n      this.shouldForceResolvers(field)\n    ) {\n      const resolverType =\n        rootValue.__typename || execContext.defaultOperationType;\n      const resolverMap = this.resolvers && this.resolvers[resolverType];\n      if (resolverMap) {\n        const resolve = resolverMap[aliasUsed ? fieldName : aliasedFieldName];\n        if (resolve) {\n          resultPromise = Promise.resolve(\n            // In case the resolve function accesses reactive variables,\n            // set cacheSlot to the current cache instance.\n            cacheSlot.withValue(this.cache, resolve, [\n              rootValue,\n              argumentsObjectFromField(field, variables),\n              execContext.context,\n              { field, fragmentMap: execContext.fragmentMap },\n            ])\n          );\n        }\n      }\n    }\n\n    return resultPromise.then((result = defaultResult) => {\n      // If an @export directive is associated with the current field, store\n      // the `as` export variable name and current result for later use.\n      if (field.directives) {\n        field.directives.forEach(directive => {\n          if (directive.name.value === 'export' && directive.arguments) {\n            directive.arguments.forEach(arg => {\n              if (arg.name.value === 'as' && arg.value.kind === 'StringValue') {\n                execContext.exportedVariables[arg.value.value] = result;\n              }\n            });\n          }\n        });\n      }\n\n      // Handle all scalar types here.\n      if (!field.selectionSet) {\n        return result;\n      }\n\n      // From here down, the field has a selection set, which means it's trying\n      // to query a GraphQLObjectType.\n      if (result == null) {\n        // Basically any field in a GraphQL response can be null, or missing\n        return result;\n      }\n\n      if (Array.isArray(result)) {\n        return this.resolveSubSelectedArray(field, result, execContext);\n      }\n\n      // Returned value is an object, and the query has a sub-selection. Recurse.\n      if (field.selectionSet) {\n        return this.resolveSelectionSet(\n          field.selectionSet,\n          result,\n          execContext,\n        );\n      }\n    });\n  }\n\n  private resolveSubSelectedArray(\n    field: FieldNode,\n    result: any[],\n    execContext: ExecContext,\n  ): any {\n    return Promise.all(\n      result.map(item => {\n        if (item === null) {\n          return null;\n        }\n\n        // This is a nested array, recurse.\n        if (Array.isArray(item)) {\n          return this.resolveSubSelectedArray(field, item, execContext);\n        }\n\n        // This is an object, run the selection set on it.\n        if (field.selectionSet) {\n          return this.resolveSelectionSet(field.selectionSet, item, execContext);\n        }\n      }),\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}